---
description:
globs:
alwaysApply: false
---
# Redux 状态管理规范

## Critical Rules

- 项目必须使用Redux进行全局状态管理
- 必须使用Redux Toolkit (RTK) 而不是原生Redux
- 所有异步操作必须使用createAsyncThunk
- Store必须使用TypeScript进行类型安全配置
- 业务状态与3D场景状态在Redux中分别管理
- 使用RTK Query处理API数据获取和缓存
- Slice命名必须清晰描述其负责的状态域
- 避免在Redux中存储不可序列化的数据（如函数、类实例）
- 使用Immer进行状态更新，避免直接修改state
- 复杂的状态逻辑必须使用createSlice的extraReducers

## Examples

<example>
  // Good - 使用Redux Toolkit创建store
  import { configureStore } from '@reduxjs/toolkit';
  import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
  
  import userSlice from './slices/userSlice';
  import sceneSlice from './slices/sceneSlice';
  import apiSlice from './api/apiSlice';

  export const store = configureStore({
    reducer: {
      user: userSlice,
      scene: sceneSlice,
      api: apiSlice,
    },
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        serializableCheck: {
          ignoredActions: ['persist/PERSIST'],
        },
      }),
  });

  export type RootState = ReturnType<typeof store.getState>;
  export type AppDispatch = typeof store.dispatch;

  export const useAppDispatch = () => useDispatch<AppDispatch>();
  export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

  // Good - 业务逻辑Slice
  import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

  interface User {
    id: string;
    name: string;
    email: string;
    role: 'admin' | 'user';
  }

  interface UserState {
    currentUser: User | null;
    users: User[];
    loading: boolean;
    error: string | null;
  }

  const initialState: UserState = {
    currentUser: null,
    users: [],
    loading: false,
    error: null,
  };

  // 异步thunk
  export const fetchUsers = createAsyncThunk(
    'user/fetchUsers',
    async (_, { rejectWithValue }) => {
      try {
        const response = await userAPI.getUsers();
        return response.data;
      } catch (error) {
        return rejectWithValue(error.message);
      }
    }
  );

  const userSlice = createSlice({
    name: 'user',
    initialState,
    reducers: {
      setCurrentUser: (state, action: PayloadAction<User>) => {
        state.currentUser = action.payload;
      },
      clearError: (state) => {
        state.error = null;
      },
      updateUserRole: (state, action: PayloadAction<{ userId: string; role: 'admin' | 'user' }>) => {
        const user = state.users.find(u => u.id === action.payload.userId);
        if (user) {
          user.role = action.payload.role;
        }
      },
    },
    extraReducers: (builder) => {
      builder
        .addCase(fetchUsers.pending, (state) => {
          state.loading = true;
          state.error = null;
        })
        .addCase(fetchUsers.fulfilled, (state, action) => {
          state.loading = false;
          state.users = action.payload;
        })
        .addCase(fetchUsers.rejected, (state, action) => {
          state.loading = false;
          state.error = action.payload as string;
        });
    },
  });

  export const { setCurrentUser, clearError, updateUserRole } = userSlice.actions;
  export default userSlice.reducer;

  // Good - 3D场景状态Slice
  interface SceneState {
    cameraPosition: { x: number; y: number; z: number };
    selectedObjectId: string | null;
    viewMode: '2D' | '3D' | 'mixed';
    lighting: {
      ambientIntensity: number;
      directionalIntensity: number;
    };
  }

  const sceneSlice = createSlice({
    name: 'scene',
    initialState: {
      cameraPosition: { x: 0, y: 5, z: 10 },
      selectedObjectId: null,
      viewMode: '3D' as const,
      lighting: {
        ambientIntensity: 0.5,
        directionalIntensity: 1.0,
      },
    } as SceneState,
    reducers: {
      setCameraPosition: (state, action: PayloadAction<{ x: number; y: number; z: number }>) => {
        state.cameraPosition = action.payload;
      },
      selectObject: (state, action: PayloadAction<string>) => {
        state.selectedObjectId = action.payload;
      },
      setViewMode: (state, action: PayloadAction<'2D' | '3D' | 'mixed'>) => {
        state.viewMode = action.payload;
      },
    },
  });

  // Good - 组件中使用Redux
  const UserManagementContainer: React.FC = () => {
    const dispatch = useAppDispatch();
    const { users, loading, error } = useAppSelector(state => state.user);
    const { selectedObjectId } = useAppSelector(state => state.scene);

    useEffect(() => {
      dispatch(fetchUsers());
    }, [dispatch]);

    const handleUserSelect = useCallback((userId: string) => {
      dispatch(selectObject(userId));
    }, [dispatch]);

    return (
      <div>
        {loading && <LoadingSpinner />}
        {error && <ErrorMessage message={error} />}
        <UserList users={users} onUserSelect={handleUserSelect} />
      </div>
    );
  };

  // Good - RTK Query API slice
  import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

  export const apiSlice = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({
      baseUrl: '/api',
      prepareHeaders: (headers, { getState }) => {
        const token = (getState() as RootState).user.currentUser?.token;
        if (token) {
          headers.set('authorization', `Bearer ${token}`);
        }
        return headers;
      },
    }),
    tagTypes: ['User', 'Project'],
    endpoints: (builder) => ({
      getUsers: builder.query<User[], void>({
        query: () => 'users',
        providesTags: ['User'],
      }),
      updateUser: builder.mutation<User, { id: string; updates: Partial<User> }>({
        query: ({ id, updates }) => ({
          url: `users/${id}`,
          method: 'PATCH',
          body: updates,
        }),
        invalidatesTags: ['User'],
      }),
    }),
  });

  export const { useGetUsersQuery, useUpdateUserMutation } = apiSlice;
</example>

<example type="invalid">
  // Bad - 使用原生Redux而不是RTK
  import { createStore, combineReducers } from 'redux';
  
  const userReducer = (state = {}, action) => {
    switch (action.type) {
      case 'SET_USER':
        return { ...state, user: action.payload }; // 手动展开，容易出错
      default:
        return state;
    }
  };

  // Bad - 直接修改state
  const badReducer = (state, action) => {
    switch (action.type) {
      case 'UPDATE_USER':
        state.users[0].name = action.payload; // 直接修改state
        return state;
    }
  };

  // Bad - 在Redux中存储不可序列化数据
  const badSlice = createSlice({
    name: 'scene',
    initialState: {
      camera: new THREE.Camera(), // 不可序列化
      meshRef: useRef(null), // React ref
      callback: () => {}, // 函数
    },
    reducers: {
      // ...
    },
  });

  // Bad - 没有TypeScript类型
  const useSelector = (state) => state.user; // 没有类型
  const dispatch = useDispatch(); // 没有类型

  // Bad - 组件中直接处理异步逻辑
  const BadComponent = () => {
    const [users, setUsers] = useState([]);
    
    useEffect(() => {
      // 应该在Redux中处理
      fetch('/api/users')
        .then(res => res.json())
        .then(setUsers);
    }, []);
  };

  // Bad - 混合使用多种状态管理
  const ConfusedComponent = () => {
    const [localState, setLocalState] = useState(); // 本地状态
    const contextValue = useContext(SomeContext); // Context
    const reduxState = useSelector(state => state.user); // Redux
    // 状态管理混乱
  };

  // Bad - 在3D组件中直接调用dispatch
  const Bad3DComponent = () => {
    const dispatch = useDispatch();
    
    return (
      <mesh onClick={() => {
        // 3D组件不应直接操作业务状态
        dispatch(updateUser({ id: '1', name: 'new name' }));
      }}>
        <boxGeometry />
      </mesh>
    );
  };
</example>
