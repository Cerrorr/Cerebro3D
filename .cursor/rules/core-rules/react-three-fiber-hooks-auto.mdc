---
description:
globs:
alwaysApply: false
---
# React Three Fiber Hook 封装规范

## Critical Rules

- 所有基于React Three Fiber的3D功能必须封装成自定义Hook
- Hook命名必须以 `use` 开头，采用驼峰命名法描述3D功能
- Hook名称应清晰描述其功能，如 `useRotatingMesh`、`use3DScene`、`useR3FCamera`
- 必须使用React Three Fiber的Hook（useFrame、useThree、useLoader等）
- 复杂的3D逻辑必须拆分为多个专门的Hook
- Hook应该返回明确的TypeScript类型，包含必要的ref、状态和方法
- 避免在组件内直接使用React Three Fiber底层Hook
- Hook应该处理R3F对象的生命周期管理
- 相关的Hook应该组合使用，遵循单一职责原则
- Hook应该支持配置参数以提高复用性

## Examples

<example>
  // Good - 基于React Three Fiber的旋转Hook
  import { useFrame } from '@react-three/fiber';
  import { useRef } from 'react';
  import * as THREE from 'three';

  interface UseR3FRotationOptions {
    speed?: number;
    axis?: 'x' | 'y' | 'z';
    autoStart?: boolean;
  }

  const useR3FRotation = (options: UseR3FRotationOptions = {}) => {
    const { speed = 1, axis = 'y', autoStart = true } = options;
    const meshRef = useRef<THREE.Mesh>(null);
    const [isRotating, setIsRotating] = useState(autoStart);

    useFrame((state, delta) => {
      if (meshRef.current && isRotating) {
        meshRef.current.rotation[axis] += delta * speed;
      }
    });

    return { 
      meshRef, 
      isRotating, 
      setIsRotating,
      toggleRotation: () => setIsRotating(prev => !prev)
    };
  };

  // Good - 基于useThree的相机控制Hook
  import { useThree } from '@react-three/fiber';

  interface UseR3FCameraResult {
    camera: THREE.Camera;
    setPosition: (position: THREE.Vector3) => void;
    lookAt: (target: THREE.Vector3) => void;
  }

  const useR3FCamera = (): UseR3FCameraResult => {
    const { camera } = useThree();

    const setPosition = useCallback((position: THREE.Vector3) => {
      camera.position.copy(position);
    }, [camera]);

    const lookAt = useCallback((target: THREE.Vector3) => {
      camera.lookAt(target);
    }, [camera]);

    return { camera, setPosition, lookAt };
  };

  // Good - 组合使用多个R3F Hook
  const AnimatedR3FBox: React.FC = () => {
    const { meshRef, toggleRotation } = useR3FRotation({ speed: 2 });
    const { isHovered, hoverHandlers } = useR3FHover();
    
    return (
      <mesh 
        ref={meshRef} 
        {...hoverHandlers}
        onClick={toggleRotation}
        scale={isHovered ? 1.2 : 1.0}
      >
        <boxGeometry args={[1, 1, 1]} />
        <meshStandardMaterial color={isHovered ? 'orange' : 'blue'} />
      </mesh>
    );
  };

  // Good - 使用useLoader的材质Hook
  import { useLoader } from '@react-three/fiber';
  import { TextureLoader } from 'three';

  interface UseR3FTextureResult {
    texture: THREE.Texture | null;
    isLoading: boolean;
    error: Error | null;
  }

  const useR3FTexture = (url: string): UseR3FTextureResult => {
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);
    
    const texture = useLoader(TextureLoader, url, 
      () => setIsLoading(false),
      undefined,
      (err) => setError(err)
    );

    return { texture, isLoading, error };
  };
</example>

<example type="invalid">
  // Bad - 直接在组件中使用React Three Fiber Hook
  import { useFrame } from '@react-three/fiber';

  const RotatingBox: React.FC = () => {
    const meshRef = useRef<THREE.Mesh>(null);
    
    useFrame((state, delta) => {
      if (meshRef.current) {
        meshRef.current.rotation.y += delta;
      }
    });

    return <mesh ref={meshRef}>...</mesh>;
  };

  // Bad - 使用原生Three.js而非React Three Fiber
  import * as THREE from 'three';

  const useThreeJSAnimation = () => {
    // 直接操作Three.js对象，不通过R3F
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    // 这违反了R3F的声明式模式
  };

  // Bad - Hook命名不明确基于R3F
  const useAnimation = () => {
    // 命名太泛化，不明确是R3F相关
  };

  const meshHelper = () => {
    // 没有use前缀，不是有效的Hook
  };

  // Bad - 没有使用React Three Fiber的Hook系统
  const use3DRotation = () => {
    const meshRef = useRef<THREE.Mesh>(null);
    
    // 使用setTimeout而非useFrame
    useEffect(() => {
      const interval = setInterval(() => {
        if (meshRef.current) {
          meshRef.current.rotation.y += 0.01;
        }
      }, 16);
      
      return () => clearInterval(interval);
    }, []);

    return { meshRef };
  };

  // Bad - 没有TypeScript类型定义
  const useR3FMesh = () => {
    const ref = useRef(); // 没有类型
    return ref; // 返回值没有类型
  };
</example>
